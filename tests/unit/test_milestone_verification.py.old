"""
Comprehensive milestone verification test.
Tests all implemented and missing features.
"""
from engine.sql.parser import Parser
from engine.sql.tokenizer import Tokenizer
from backend.app.db.query import build_plan, execute_plan
from engine.engine import Engine


def run_sql(engine, sql: str):
    """Tokenize, parse, plan, and execute a SQL statement."""
    tokenizer = Tokenizer(sql)
    tokens = tokenizer.tokenize()
    parser = Parser(tokens)
    ast = parser.parse()
    plan = build_plan(ast)
    return execute_plan(plan, engine)


print("=" * 60)
print("MILESTONE A: SQL SURFACE UPGRADE (PARSER + AST)")
print("=" * 60)

engine = Engine()

# Test DROP TABLE parsing
try:
    run_sql(engine, "CREATE TABLE test (id INTEGER);")
    print("✓ CREATE TABLE works")
except Exception as e:
    print(f"✗ CREATE TABLE failed: {e}")

try:
    run_sql(engine, "DROP TABLE test;")
    print("✓ DROP TABLE parsing and execution works")
except Exception as e:
    print(f"✗ DROP TABLE failed: {e}")

# Test NOT NULL, PRIMARY KEY, AUTO_INCREMENT, VARCHAR parsing
try:
    tokenizer = Tokenizer("CREATE TABLE users (id INTEGER PRIMARY KEY AUTO_INCREMENT, name VARCHAR(100) NOT NULL);")
    tokens = tokenizer.tokenize()
    parser = Parser(tokens)
    ast = parser.parse()
    print("✓ Extended CREATE TABLE (NOT NULL, PRIMARY KEY, AUTO_INCREMENT, VARCHAR) parses")
except Exception as e:
    print(f"✗ Extended CREATE TABLE parsing failed: {e}")

# Test DELETE parsing and execution
try:
    engine2 = Engine()
    run_sql(engine2, "CREATE TABLE users (id INTEGER, name TEXT);")
    run_sql(engine2, "INSERT INTO users VALUES (1, 'Alice');")
    run_sql(engine2, "INSERT INTO users VALUES (2, 'Bob');")
    result = run_sql(engine2, "DELETE FROM users WHERE id = 1;")
    assert result == [{"deleted": 1}], f"Expected {[{'deleted': 1}]}, got {result}"
    print("✓ DELETE FROM ... WHERE ... works")
except Exception as e:
    print(f"✗ DELETE failed: {e}")

# Test UPDATE parsing and execution
try:
    engine3 = Engine()
    run_sql(engine3, "CREATE TABLE users (id INTEGER, age INTEGER);")
    run_sql(engine3, "INSERT INTO users VALUES (1, 30);")
    result = run_sql(engine3, "UPDATE users SET age = 31 WHERE id = 1;")
    assert result == [{"updated": 1}], f"Expected {[{'updated': 1}]}, got {result}"
    print("✓ UPDATE ... SET ... WHERE ... works")
except Exception as e:
    print(f"✗ UPDATE failed: {e}")

print("\n" + "=" * 60)
print("MILESTONE B: DML & DDL EXECUTION SEMANTICS")
print("=" * 60)

try:
    engine4 = Engine()
    run_sql(engine4, "CREATE TABLE test (id INTEGER);")
    assert "TEST" in engine4.catalog.tables
    run_sql(engine4, "DROP TABLE test;")
    assert "TEST" not in engine4.catalog.tables
    print("✓ Milestone B: DML/DDL execution complete")
except Exception as e:
    print(f"✗ Milestone B incomplete: {e}")

print("\n" + "=" * 60)
print("MILESTONE C: COLUMN CONSTRAINTS ENFORCEMENT")
print("=" * 60)

# Check if constraints are stored in Column metadata
try:
    engine5 = Engine()
    tokenizer = Tokenizer("CREATE TABLE users (id INTEGER PRIMARY KEY NOT NULL, name TEXT NOT NULL);")
    tokens = tokenizer.tokenize()
    parser = Parser(tokens)
    ast = parser.parse()
    
    # Check if ColumnDef has constraints
    if hasattr(ast.columns[0], 'constraints'):
        print("✓ Constraint metadata is parsed and stored in AST")
    else:
        print("✗ Constraint metadata not available in AST")
    
    # Check if constraints are enforced (this would require constraint metadata in Column)
    # For now, just check if they exist
    from engine.catalog.column import Column
    if hasattr(Column, 'constraints'):
        print("✓ Column object stores constraints")
    else:
        print("✗ Column object does not store constraints (NOT YET IMPLEMENTED)")
        
except Exception as e:
    print(f"✗ Constraint checking failed: {e}")

print("\n" + "=" * 60)
print("MILESTONE D: JOIN SUPPORT")
print("=" * 60)

try:
    engine6 = Engine()
    run_sql(engine6, "CREATE TABLE users (id INTEGER, name TEXT);")
    run_sql(engine6, "CREATE TABLE orders (id INTEGER, user_id INTEGER, product TEXT);")
    
    run_sql(engine6, "INSERT INTO users VALUES (1, 'Alice');")
    run_sql(engine6, "INSERT INTO orders VALUES (1, 1, 'Book');")
    
    result = run_sql(engine6, "SELECT id, name, product FROM users INNER JOIN orders ON id = user_id;")
    
    expected = [{"id": 1, "name": "Alice", "product": "Book"}]
    assert result == expected, f"Expected {expected}, got {result}"
    print("✓ Milestone D: INNER JOIN works")
except Exception as e:
    print(f"✗ Milestone D failed: {e}")

print("\n" + "=" * 60)
print("MILESTONE E: QUERY SHAPING (ORDER BY, LIMIT, GROUP BY, etc.)")
print("=" * 60)

features = [
    ("ORDER BY", "SELECT id FROM users ORDER BY id DESC;"),
    ("LIMIT", "SELECT id FROM users LIMIT 10;"),
    ("OFFSET", "SELECT id FROM users OFFSET 5;"),
    ("GROUP BY", "SELECT user_id, COUNT(*) FROM orders GROUP BY user_id;"),
    ("HAVING", "SELECT user_id FROM orders GROUP BY user_id HAVING COUNT(*) > 1;"),
]

for feature_name, sql_query in features:
    try:
        tokenizer = Tokenizer(sql_query)
        tokens = tokenizer.tokenize()
        parser = Parser(tokens)
        ast = parser.parse()
        print(f"✓ {feature_name} parses (AST: {type(ast).__name__})")
    except Exception as e:
        print(f"✗ {feature_name} not implemented: {type(e).__name__}")

print("\n" + "=" * 60)
print("API CLEANUP")
print("=" * 60)

try:
    from backend.app import urls
    patterns = [p.pattern.regex.pattern for p in urls.urlpatterns]
    print(f"Current endpoints: {patterns}")
    if 'query/' in str(patterns):
        print("✓ POST /query exists (all-purpose SQL)")
    print("✗ Structured endpoints not yet implemented (GET /tables, POST /tables/{name}/rows, etc.)")
except Exception as e:
    print(f"✗ Could not inspect URLs: {e}")

print("\n" + "=" * 60)
print("SUMMARY")
print("=" * 60)
